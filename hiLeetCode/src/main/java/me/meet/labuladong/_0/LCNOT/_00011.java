package me.meet.labuladong._0.LCNOT;

public final class _00011 {
    private _00011() {
    }

    /*
     * DFS 算法秒杀五道岛屿问题
     *
     * 读完本文，可以去力扣解决如下题目：
     * 200.岛屿数量（中等）
     * 1254.统计封闭岛屿的数目（中等）
     * 1020.飞地的数量（中等）
     * 1905.统计子岛屿（中等）
     * 694.不同的岛屿数量（中等）
     *
     *
     * 岛屿问题是经典的面试高频题，虽然基本的岛屿问题并不难，但是岛屿问题有一些有意思的扩展，比如求子岛屿数量，求形状不同的岛屿数量等等，本文就来把这些问题一网打尽。
     * 岛屿系列问题的核心考点就是用 DFS/BFS 算法遍历二维数组。
     * 本文主要来讲解如何用 DFS 算法来秒杀岛屿系列问题，不过用 BFS 算法的核心思路是完全一样的，无非就是把 DFS 改写成 BFS 而已。
     * 那么如何在二维矩阵中使用 DFS 搜索呢？
     * 如果你把二维矩阵中的每一个位置看做一个节点，这个节点的上下左右四个位置就是相邻节点，那么整个矩阵就可以抽象成一幅网状的「图」结构。
     * 根据 学习数据结构和算法的框架思维，完全可以根据二叉树的遍历框架改写出二维矩阵的 DFS 代码框架：
     * // 二叉树遍历框架
     * void traverse(TreeNode root) {
     *     traverse(root.left);
     *     traverse(root.right);
     * }
     *
     * // 二维矩阵遍历框架
     * void dfs(int[][] grid, int i, int j, boolean[] visited) {
     *     int m = grid.length, n = grid[0].length;
     *     if (i < 0 || j < 0 || i >= m || j >= n) {
     *         // 超出索引边界
     *         return;
     *     }
     *     if (visited[i][j]) {
     *         // 已遍历过 (i, j)
     *         return;
     *     }
     *     // 前序：进入节点 (i, j)
     *     visited[i][j] = true;
     *     dfs(grid, i - 1, j); // 上
     *     dfs(grid, i + 1, j); // 下
     *     dfs(grid, i, j - 1); // 左
     *     dfs(grid, i, j + 1); // 右
     *     // 后序：离开节点 (i, j)
     *     // visited[i][j] = true;
     * }
     *
     * 因为二维矩阵本质上是一幅「图」，所以遍历的过程中需要一个visited布尔数组防止走回头路，如果你能理解上面这段代码，那么搞定所有岛屿问题都很简单。
     * 这里额外说一个处理二维数组的常用小技巧，你有时会看到使用「方向数组」来处理上下左右的遍历，和前文 图遍历框架 的代码很类似：
     * // 方向数组，分别代表上、下、左、右
     * int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};
     *
     * void dfs(int[][] grid, int i, int j, boolean[] visited) {
     *     int m = grid.length, n = grid[0].length;
     *     if (i < 0 || j < 0 || i >= m || j >= n) {
     *         // 超出索引边界
     *         return;
     *     }
     *     if (visited[i][j]) {
     *         // 已遍历过 (i, j)
     *         return;
     *     }
     *
     *     // 进入节点 (i, j)
     *     visited[i][j] = true;
     *     // 递归遍历上下左右的节点
     *     for (int[] d : dirs) {
     *         int next_i = i + d[0];
     *         int next_j = j + d[1];
     *         dfs(grid, next_i, next_j);
     *     }
     *     // 离开节点 (i, j)
     *     // visited[i][j] = true;
     * }
     *
     * 这种写法无非就是用 for 循环处理上下左右的遍历罢了，你可以按照个人喜好选择写法。
     *
     *
     *
     * 岛屿数量
     * 这是力扣第 200 题「岛屿数量」，最简单也是最经典的一道岛屿问题，
     * 题目会输入一个二维数组grid，其中只包含0或者1，0代表海水，1代表陆地，且假设该矩阵四周都是被海水包围着的。
     * 我们说连成片的陆地形成岛屿，那么请你写一个算法，计算这个矩阵grid中岛屿的个数，函数签名如下：
     * int numIslands(char[][] grid);
     *
     *
     *
     * 封闭岛屿的数量
     * 力扣第 1254 题「统计封闭岛屿的数目」和上一题有两点不同：
     * 上一题说二维矩阵四周可以认为也是被海水包围的，所以靠边的陆地也算作岛屿。
     * 1>用0表示陆地，用1表示海水。
     * 2>让你计算「封闭岛屿」的数目。
     *   所谓「封闭岛屿」就是上下左右全部被1包围的0，也就是说靠边的陆地不算作「封闭岛屿」。
     * int closedIsland(int[][] grid)
     *
     * 这道岛屿题目的解法稍微改改就可以解决力扣第 1020 题「飞地的数量」，
     * 这题不让你求封闭岛屿的数量，而是求封闭岛屿的面积总和。
     * 其实思路都是一样的，先把靠边的陆地淹掉，然后去数剩下的陆地数量就行了，注意第 1020 题中1代表陆地，0代表海水：
     *
     *
     *
     * 岛屿的最大面积
     * 这是力扣第 695 题「岛屿的最大面积」，0表示海水，1表示陆地，现在不让你计算岛屿的个数了，而是让你计算最大的那个岛屿的面积，函数签名如下：
     * int maxAreaOfIsland(int[][] grid)
     *
     * 这题的大体思路和之前完全一样，只不过dfs函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积。
     *
     * 1 1 1 1 1 1 1 0
     * 1 0 0 0 0 1 1 0
     * 1 0 1 0 1 1 1 0
     * 1 0 0 0 0 1 0 1
     * 1 1 1 1 1 1 1 0
     *
     * 我们可以给dfs函数设置返回值，记录每次淹没的陆地的个数，直接看解法吧：
     *
     *
     *
     * 子岛屿数量
     * 如果说前面的题目都是模板题，那么力扣第 1905 题「统计子岛屿」可能得动动脑子了：
     * 这道题的关键在于，如何快速判断子岛屿？
     * 肯定可以借助 Union Find 并查集算法 来判断，不过本文重点在 DFS 算法，就不展开并查集算法了。
     *
     * 什么情况下grid2中的一个岛屿B是grid1中的一个岛屿A的子岛？
     * 当岛屿B中所有陆地在岛屿A中也是陆地的时候，岛屿B是岛屿A的子岛。
     * 反过来说，如果岛屿B中存在一片陆地，在岛屿A的对应位置是海水，那么岛屿B就不是岛屿A的子岛。
     * 那么，我们只要遍历grid2中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。
     * 依据这个思路，可以直接写出下面的代码：
     *
     * 这道题的思路和计算「封闭岛屿」数量的思路有些类似，只不过后者排除那些靠边的岛屿，前者排除那些不可能是子岛的岛屿。
     *
     *
     *
     * 不同的岛屿数量
     * 力扣第 694 题「不同的岛屿数量」，题目还是输入一个二维矩阵，0表示海水，1表示陆地，这次让你计算 不同的 (distinct) 岛屿数量，函数签名如下：
     * int numDistinctIslands(int[][] grid)
     *
     * 比如题目输入下面这个二维矩阵：
     *
     * 1 1 0 1 1
     * 1 0 0 0 0
     * 0 0 0 0 1
     * 1 1 0 1 1
     *
     * 其中有四个岛屿，但是左下角和右上角的岛屿形状相同，所以不同的岛屿共有三个，算法返回 3。
     * 很显然我们得想办法把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。
     * 如果想把岛屿转化成字符串，说白了就是序列化，序列化说白了遍历嘛，前文 二叉树的序列化和反序列化 讲了二叉树和字符串互转，这里也是类似的。
     *
     * 首先，对于形状相同的岛屿，如果从同一起点出发，dfs函数遍历的顺序肯定是一样的。
     * 因为遍历顺序是写死在你的递归函数里面的，不会动态改变：
     *
     * void dfs(int[][] grid, int i, int j) {
     *     // 递归顺序：
     *     dfs(grid, i - 1, j); // 上
     *     dfs(grid, i + 1, j); // 下
     *     dfs(grid, i, j - 1); // 左
     *     dfs(grid, i, j + 1); // 右
     * }
     *
     * 所以，遍历顺序从某种意义上说就可以用来描述岛屿的形状，比如下图这两个岛屿：
     * 假设它们的遍历顺序是：下，右，上，撤销上，撤销右，撤销下
     * 如果我用分别用1, 2, 3, 4代表上下左右，用-1, -2, -3, -4代表上下左右的撤销，
     * 那么可以这样表示它们的遍历顺序：2, 4, 1, -1, -4, -2
     *
     * 你看，这就相当于是岛屿序列化的结果，只要每次使用dfs遍历岛屿的时候生成这串数字进行比较，就可以计算到底有多少个不同的岛屿了。
     * 要想生成这段数字，需要稍微改造dfs函数，添加一些函数参数以便记录遍历顺序：
     *
     * void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) {
     *     int m = grid.length, n = grid[0].length;
     *     if (i < 0 || j < 0 || i >= m || j >= n
     *         || grid[i][j] == 0) {
     *         return;
     *     }
     *     // 前序遍历位置：进入 (i, j)
     *     grid[i][j] = 0;
     *     sb.append(dir).append(',');
     *
     *     dfs(grid, i - 1, j, sb, 1); // 上
     *     dfs(grid, i + 1, j, sb, 2); // 下
     *     dfs(grid, i, j - 1, sb, 3); // 左
     *     dfs(grid, i, j + 1, sb, 4); // 右
     *
     *     // 后序遍历位置：离开 (i, j)
     *     sb.append(-dir).append(',');
     * }
     *
     * dir记录方向，dfs函数递归结束后，sb记录着整个遍历顺序，其实这就是前文 回溯算法核心套路 说到的回溯算法框架，你看到头来这些算法都是相通的。
     * 有了这个dfs函数就好办了，我们可以直接写出最后的解法代码：
     *
     * int numDistinctIslands(int[][] grid) {
     *     int m = grid.length, n = grid[0].length;
     *     // 记录所有岛屿的序列化结果
     *     HashSet<String> islands = new HashSet<>();
     *     for (int i = 0; i < m; i++) {
     *         for (int j = 0; j < n; j++) {
     *             if (grid[i][j] == 1) {
     *                 // 淹掉这个岛屿，同时存储岛屿的序列化结果
     *                 StringBuilder sb = new StringBuilder();
     *                 // 初始的方向可以随便写，不影响正确性
     *                 dfs(grid, i, j, sb, 666);
     *                 islands.add(sb.toString());
     *             }
     *         }
     *     }
     *     // 不相同的岛屿数量
     *     return islands.size();
     * }
     *
     * 这样，这道题就解决了，至于为什么初始调用dfs函数时的dir参数可以随意写，
     * 这里涉及 DFS 和回溯算法的一个细微差别，前文 图算法基础 有写，这里就不展开了。
     * 以上就是全部岛屿系列问题的解题思路，也许前面的题目大部分人会做，但是最后两题还是比较巧妙的，希望本文对你有帮助。
     *
     *
     */

}
