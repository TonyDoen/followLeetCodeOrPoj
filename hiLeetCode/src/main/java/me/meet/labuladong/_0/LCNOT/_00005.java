package me.meet.labuladong._0.LCNOT;

import java.util.Arrays;
import java.util.List;

public final class _00005 {
    private _00005() {
    }

    /*
     * 参考 URL:
     * https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484520&idx=1&sn=2c6507c7f25c0fd29fd1d146ee3b067c&chksm=9bd7fa60aca073763785418d15ed03c9debdd93ca36f4828fa809990116b1e7536c3f68a7b71&scene=21#wechat_redirect
     * https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&scene=21#wechat_redirect
     *
     * 先声明一下：首先，这里讲的都是普通的数据结构，咱不是搞算法竞赛的，自学野路子出生，很多厉害的知识我不会，我只会解决常规的问题。
     * 另外，以下是我个人的经验的总结，没有哪本书会写这些东西，所以请读者试着理解我的角度，如果不是严重的逻辑错误，没必要纠结于细节问题，因为这篇文章就是希望对数据结构和算法建立一个框架性的认识。
     * 相信大家能从这篇文章里学到点东西。
     *
     * 一、数据结构千变万化，但不离其宗
     * 最高层的抽象，数据结构只有两种：数组和链表。
     * 这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？
     * 我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你列出的这么多，都属于「上层建筑」，而数组和链表才是「结构基础」。
     * 因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。
     * 比如说
     * 「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的空间存储节点指针。
     * 「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是一般比较耗费空间。邻接表比较节省空间，但是时间上肯定不如邻接矩阵快。
     * 「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要空间；线性探查法就需要数组特性，以便连续寻址，省空间，但操作稍微复杂些。
     * 「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。
     * 为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。
     * 以上也可以看出，没有完美的数据结构，没有一劳永逸的解决方案。
     *
     * 综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：
     * 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，
     * 所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
     * 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。
     * 但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。
     *
     *
     * 二、数据结构的操作,无非遍历 + 访问
     * 遍历 + 访问，再具体一点就是：增删查改。
     * 数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。试问，除此之外还有其他吗？
     * 如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式，线性的和非线性的。
     * 线性就是 for/while 为代表，非线性就是递归为代表。无非以下两种框架：
     *
     * 数组遍历框架，典型的线性遍历结构：
     * void traverse(int[] arr) {
     *     for (int i = 0; i < arr.length; i++) {
     *         // 访问 arr[i]
     *     }
     * }
     *
     * 二叉树遍历框架，典型的非线性递归遍历结构：
     * void traverse(TreeNode root) {
     *     traverse(root.left)
     *     traverse(root.right)
     * }
     *
     * 以上两个框架可以随意改造。
     * 链表遍历框架，兼具线性和非线性遍历结构：
     * void traverse(ListNode head) {
     *     for (ListNode p = head; p != null; p = p.next) {
     *         // 访问 p.val
     *     }
     * }
     *
     * void traverse(ListNode head) {
     *     // 访问 head.val
     *     traverse(head.next)
     * }
     *
     * 二叉树框架又可以具体扩展为 N 叉树的遍历框架：
     * class TreeNode {
     *     int val;
     *     TreeNode[] children;
     * }
     * void traverse(TreeNode root) {
     *     for (TreeNode child : root.children)
     *         traverse(child)
     * }
     * N 叉树的遍历又可以扩展为图的遍历，因为，图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，就不贴代码了。
     * 所谓框架，就是说不管具体问题是什么，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了。
     *
     *
     * 三、为什么算法总是和数据结构同时出现
     * 数据结构是工具，算法是通过合适的工具解决问题的方法。
     * 拿原始人举例，我们学会了数据结构，就像原始人拥有了石刀，石斧等工具。而根据制造工具的工艺不同，石刀又分尖锐的石刀和锯齿状石刀，前者适合打猎，后者适合切割；
     * 就像「图」这种数据结构通过不同的实现方法（链表、数组），可以表示为邻接表和邻接矩阵，前者适合处理非稠密图，后者适合处理稠密图。
     *
     * 原始人想要造一栋房子，就要进行规划，石斧砍树，石刀磨尖角等等；就像我们设计算法，发挥数据结构的特性，去解决实际问题。
     * 算法利用数据结构，可以显式利用，比如说前文讲解的 单调栈，就是巧妙地直接利用了栈结构先进后出的特性。稍微高级一点的算法设计思路，就是隐式利用数据结构，
     * 比如前文讲过的 回溯算法、动态规划，以及传说中的的分治算法，都在利用树这种结构来解决问题。
     *
     * 但是，无论怎样利用数据结构，多么高大上的算法，其解法都逃不出第二点中相应的框架，是不是？
     *
     *
     * 四、最后总结（重要）
     * 对于一个初学算法的人来说，一定要学会从框架上看问题，而不要纠结于细节问题。
     * 啥叫细节问题？比如说 i 到底应该加到 n 还是加到 n - 1 ？这个数组的大小到底应该开 n 还是 n + 1 ？
     * 啥叫从框架上看问题？比如说前文 动态规划 中凑零钱的问题，如果你看了一眼代码就自动排除细节问题，直接提取出 N 叉树遍历框架，那么你的框架思维就到位了。
     *
     * 当然，如果细节出错，你得不到正确的答案，但是只要有框架在，你再错也错不到哪去，因为你的方向是对的。
     * 但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。
     * 这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。
     * 初学阶段，没到纠结细节的地步。细节出错，可以有各种方法查出来，比如到处打 log，没有找不到的 bug 。
     * 相比之下，别人还束手无策的时候，你已经做出了一个错误的答案；当别人没有框架的指导，被无限细节劝退数据结构的时候，你已经借助框架看穿了数据结构的本质。
     * 这不就是一种巨大的成功吗？给你鼓掌。
     *
     */

    /**
     * // N 叉树遍历框架
     * int coinChange(List<Integer> coins, int amount) {
     *     for (int coin : coins) {
     *         coinChange(coins, amount-coin)
     *     }
     * }
     *
     * # 不过是一个 N 叉树的遍历问题而已
     * def dp(n):
     *     for coin in coins:
     *         dp(n - coin)
     *
     * // coins 中是可选硬币面值，amount 是目标金额
     * @param coins  拥有的钱币
     * @param amount 总额
     * @return 找零方式
     */
    static int coinChange(List<Integer> coins, int amount) {
        if (amount == 0) return 0;
        int ans = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 金额不可达
            if (amount - coin < 0) continue;
            int subProb = coinChange(coins, amount - coin);
            // 子问题无解
            if (subProb == -1) continue;
            ans = Math.min(ans, subProb + 1);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

    /*
     * 综上，对于算法无从下手的朋友来说，可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题。
     * 纠结细节问题，就比如纠结 i 到底应该加到 n 还是加到 n - 1，这个数组的大小到底应该开 n 还是 n + 1 ？
     * 从框架上看问题，就是像我们这样基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。
     * 当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。
     * 但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。
     * 这种思维是很重要的，动态规划详解 中总结的找状态转移方程的几步流程，有时候按照流程写出解法，说实话我自己都不知道为啥是对的，反正它就是对了。。。
     * 这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。
     *
     *
     * 最后总结
     * 数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。
     * 刷算法题建议从「树」分类开始刷，结合框架思维，把这几十道题刷完，对于树结构的理解应该就到位了。这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些。
     * 最后，除了树的问题，还有一些其他类型问题的框架套路，我都有总结过，在下面简单列一下：
     *
     * 滑动窗口技巧解决子串问题
     * 双指针技巧汇总
     * 前缀和技巧：解决子数组问题
     * 二分查找算法书写技巧
     * Two Sum 问题的核心思想
     * 如何用算法高效寻找素数？
     * 如何高效对有序数组/链表去重？
     */
    public static void main(String[] args) {
        // 有几种找零方式
        List<Integer> coins = Arrays.asList(1,2,2,3,4,5,6,7,8,9,11);
        int amount = 23;
        int cnt = coinChange(coins, amount);
        System.out.println("there are approximately " + cnt + " ways to change money");
    }
}
