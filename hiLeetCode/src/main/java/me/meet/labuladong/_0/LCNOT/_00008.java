package me.meet.labuladong._0.LCNOT;

public final class _00008 {
    private _00008() {
    }

    /*
     * 其实 DFS 算法就是回溯算法，我们前文 回溯算法框架套路详解 就写过了 _00007
     *
     * BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。
     * 一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。
     * BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多，至于为什么，我们后面介绍了框架就很容易看出来了。
     *
     * 一、算法框架
     * 要说框架的话，我们先举例一下 BFS 出现的常见场景好吧，问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离，
     * 这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿。
     *
     * 把枯燥的本质搞清楚了，再去欣赏各种问题的包装才能胸有成竹嘛。
     * 这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？
     * 再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？
     * 再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？
     *
     * 净整些花里胡哨的，这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。
     *
     * // 计算从起点 start 到终点 target 的最近距离
     * int BFS(Node start, Node target) {
     *     Queue<Node> q; // 核心数据结构
     *     Set<Node> visited; // 避免走回头路
     *
     *     q.offer(start); // 将起点加入队列
     *     visited.add(start);
     *     int step = 0; // 记录扩散的步数
     *
     *     while (q not empty) {
     *         int sz = q.size();
     *         // 将当前队列中的所有节点向四周扩散
     *         for (int i = 0; i < sz; i++) {
     *             Node cur = q.poll();
     *             // 划重点：这里判断是否到达终点
     *             if (cur is target)
     *                 return step;
     *             // 将 cur 的相邻节点加入队列
     *             for (Node x : cur.adj())
     *                 if (x not in visited) {
     *                     q.offer(x);
     *                     visited.add(x);
     *                 }
     *         }
     *         // 划重点：更新步数在这里
     *         step++;
     *    }
     * }
     * 队列q就不说了，BFS 的核心数据结构；
     * cur.adj()泛指cur相邻的节点，比如说二维数组中，cur上下左右四面的位置就是相邻节点；
     * visited的主要作用是防止走回头路，大部分时候都是必须的，
     * 但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要visited。
     *
     */

    /*
     * 拓展阅读 A* 算法(常用的路径查找和图形遍历算法)
     * uri: https://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
     * uri: https://zhuanlan.zhihu.com/p/54510444
     *
     * 算法介绍
     * A*（念做：A Star）算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。
     * 本文在讲解算法的同时也会提供Python语言的代码实现，并会借助matplotlib库动态的展示算法的运算过程。
     * A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。
     * 由于借助启发函数的引导，A*算法通常拥有更好的性能。
     *
     * 广度优先搜索
     * 为了更好的理解A*算法，我们首先从广度优先（Breadth First）算法讲起。
     * 正如其名称所示，广度优先搜索以广度做为优先级进行搜索。
     * 从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。
     * 这种算法就像洪水（Flood fill）一样向外扩张，算法遍历了图中所有的点，这通常没有必要。
     * 对于有明确终点的问题来说，一旦到达终点便可以提前终止算法，在执行算法的过程中，每个点需要记录达到该点的前一个点的位置 -- 可以称之为父节点。
     * 这样做之后，一旦到达终点，便可以从终点开始，反过来顺着父节点的顺序找到起点，由此就构成了一条路径。
     *
     * Dijkstra算法
     * Dijkstra算法是由计算机科学家Edsger W. Dijkstra在1956年提出的。
     * Dijkstra算法用来寻找图形中节点之间的最短路径。考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。
     * 例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。
     * 在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。
     * 在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。
     * 当图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。
     *
     * 最佳优先搜索
     * 在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。
     * 其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。
     * 这种算法称之为最佳优先（Best First）算法。 这样做可以大大加快路径的搜索速度，如下图所示
     * 但这种算法会不会有什么缺点呢？如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。
     *
     * A*算法
     * 对比了上面几种算法，最后终于可以讲解本文的重点：A*算法了。
     * 下面的描述我们将看到，A*算法实际上是综合上面这些算法的特点于一身的。
     * A*算法通过下面这个函数来计算每个节点的优先级。
     *
     * f(n) = g(n) + h(n)
     *
     * 其中：
     * f(n) 是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。
     * g(n) 是节点n距离起点的代价。
     * h(n) 是节点n距离终点的预计代价，这也就是A*算法的启发函数。关于启发函数我们在下面详细讲解
     *
     * A* 算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。
     * 另外，A* 算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为 open_set 和 close_set。
     *
     * 完整的A*算法描述如下：
     * * 初始化open_set和close_set；
     * * 将起点加入open_set中，并设置优先级为0（优先级最高）；
     * * 如果open_set不为空，则从open_set中选取优先级最高的节点n：
     *     * 如果节点n为终点，则：
     *         * 从终点开始逐步追踪parent节点，一直达到起点；
     *         * 返回找到的结果路径，算法结束；
     *     * 如果节点n不是终点，则：
     *         * 将节点n从open_set中删除，并加入close_set中；
     *         * 遍历节点n所有的邻近节点：
     *             * 如果邻近节点m在close_set中，则：
     *                 * 跳过，选取下一个邻近节点
     *             * 如果邻近节点m也不在open_set中，则：
     *                 * 设置节点m的parent为节点n
     *                 * 计算节点m的优先级
     *                 * 将节点m加入open_set中
     *
     * 启发函数
     * 上面已经提到，启发函数会影响A*算法的行为。
     * 1>在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。
     * 2>如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
     * 3>如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。
     * 4>如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。
     * 5>在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。
     *
     * 由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。
     * 因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方
     *
     *
     * 对于网格形式的图，有以下这些启发函数可以使用：
     * 1>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。
     * 2>如果图形中允许朝八个方向移动(允许对角线移动)，则可以使用对角距离。
     * 3>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。
     *
     * 关于距离
     * 曼哈顿距离：如果图形中只允许朝上下左右四个方向移动，则启发函数可以使用曼哈顿距离，它的计算方法如下图所示：
     * 计算曼哈顿距离的函数如下，这里的D是指两个相邻节点之间的移动代价，通常是一个固定的常数。
     * function heuristic(node) =
     *     dx = abs(node.x - goal.x)
     *     dy = abs(node.y - goal.y)
     *     return D * (dx + dy)
     *
     * 对角距离：如果图形中允许斜着朝邻近的节点移动，则启发函数可以使用对角距离。它的计算方法如下：
     * 计算对角距离的函数如下，这里的D2指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是
     * function heuristic(node) =
     *     dx = abs(node.x - goal.x)
     *     dy = abs(node.y - goal.y)
     *     return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)
     *
     * 欧几里得距离
     * 如果图形中允许朝任意方向移动，则可以使用欧几里得距离。
     * 欧几里得距离是指两个节点之间的直线距离，因此其计算方法也是我们比较熟悉的：
     * function heuristic(node) =
     *     dx = abs(node.x - goal.x)
     *     dy = abs(node.y - goal.y)
     *     return D * sqrt(dx * dx + dy * dy)
     *
     *
     * 算法变种
     * A*算法有不少的变种，这里我们介绍最主要的几个。
     * ARA*
     * ARA* 全称是Anytime Repairing A，也称为Anytime A。
     * 与其他Anytime算法一样，它具有灵活的时间成本，即使在它结束之前被中断，也可以返回路径查找或图形遍历问题的有效解决方案。方法是在逐步优化之前生成快速，非最优的结果。
     * 在现实世界的规划问题中，问题的解决时间往往是有限的。与时间相关的规划者对这种情况都会比较熟悉：他们能够快速找到可行的解决方案，然后不断努力改进，直到时间用完为止。
     * 启发式搜索ARA算法，它根据可用的搜索时间调整其性能边界。它首先使用松散边界快速找到次优解，然后在时间允许的情况下逐渐收紧边界。如果有足够的时间，它会找到可证明的最佳解决方方案。
     * 在改进其约束的同时，ARA重复使用以前的搜索工作，因此，比其他随时搜索方法更有效。
     * 与A*算法不同，Anytime A算法最重要的功能是，它们可以被停止，然后可以随时重启。
     * 该方法使用控制管理器类来处理时间限制以及停止和重新启动A*算法以找到初始的，可能是次优的解决方案，然后继续搜索改进的解决方案，直到达到可证明的最佳解决方案。
     * 论文地址:
     * https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/ARA%2A-%20Anytime%20A%2A%20with%20Provable%20Bounds%20on%20Sub-Optimality.pdf
     *
     * D*
     * D是Dynamic A的简写，其算法和A*类似，不同的是，其代价的计算在算法运行过程中可能会发生变化。
     * D*包含了下面三种增量搜索算法：
     * 原始的D*由Anthony Stentz发表。
     * Focussed D由Anthony Stentz发表，是一个增量启发式搜索算法，结合了A*和原始D*的思想。
     * D* Lite是由Sven Koenig和Maxim Likhachev基于LPA*构建的算法。
     * 所有三种搜索算法都解决了相同的基于假设的路径规划问题，包括使用自由空间假设进行规划。在这些环境中，机器人必须导航到未知地形中的给定目标坐标。
     * 它假设地形的未知部分（例如：它不包含障碍物），并在这些假设下找到从当前坐标到目标坐标的最短路径。
     * 然后机器人沿着路径行进。当它观察到新的地图信息（例如以前未知的障碍物）时，它会将信息添加到其地图中，并在必要时将新的最短路径从其当前坐标重新添加到给定的目标坐标。
     * 它会重复该过程，直到达到目标坐标或确定无法达到目标坐标。在穿越未知地形时，可能经常发现新的障碍，因此重新计划需要很快。
     * 增量（启发式）搜索算法通过使用先前问题的经验来加速搜索当前问题，从而加速搜索类似搜索问题的序列。假设目标坐标没有改变，则所有三种搜索算法都比重复的A*搜索更有效。
     *
     * D及其变体已广泛用于移动机器人和自动车辆导航。当前系统通常基于D Lite而不是原始D或Focussed D。
     * 参考资料地址:
     * http://idm-lab.org/project-a.html
     * https://www.cs.cmu.edu/~motionplanning/lecture/anytimeincrementalsearch.pdf
     *
     * Field D*
     * Field D*扩展了D和D* Lite，是一种基于插值（ interpolation-based ）的规划算法，它使用线性插值来有效地生成低成本路径，从而消除不必要的转向。
     * 在给定线性插值假设的情况下，路径是最优的，并且在实践中非常有效。该算法目前被各种现场机器人系统使用。
     * 关于Field D*的详细内容可以看下面这篇论文：
     * https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Field%20D%2A-%20An%20Interpolation-based%20Path%20Planner%20and%20Replanner.pdf
     *
     * Block A*
     * Block A扩展自A，但它操作是一块（block）单元而不是单个单元。
     * 其open_set中的每个条目都是已到达但尚未扩展的块，或者需要重新扩展的块。
     * open_set中块的优先级称为其堆值（heap value）。与A类似，Block A中的基本循环是删除具有最低堆值的条目并将其展开。在扩展期间使用LDDB来计算正在扩展的块中的边界单元的g值。
     * LDDB是一种新型数据库，它包含了本地邻域边界点之间的距离。
     * https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Block%20A%2A-%20Database-Driven%20Search%20with%20Applications%20in%20Any-angle%20Path-Planning.pdf
     *
     *
     * 总结
     * A* 算法及其变种仍然是业界路径规划中常用的算法之一。A* 算法因其有效性和效率而广泛应用于各种场景，尤其是在计算机科学和游戏开发领域。
     * A* 算法是一种启发式搜索算法，它使用启发式函数来评估从当前节点到目标节点的最佳路径。这允许算法优先考虑那些看起来可能会导致最短路径的节点，从而加快搜索速度。A* 算法的关键特点是它的灵活性，因为启发式函数可以根据不同的应用场景进行调整。
     * 除了基本的 A* 算法外，还有多种变种被开发和使用，其中包括：
     * Block A*: 专为地图上的分块路径搜索设计，能够处理大规模地图上的路由问题。
     * Field D*: 是 D* 算法的一种变体，适用于动态变化的环境，因为它能够在发现路线中的障碍物时重新规划路径。
     * Jump Point Search (JPS): 是 A* 的一个优化，通过跳过某些节点来减少需要评估的节点数量，提高了算法在网格地图上的运行效率。
     * Theta*: 类似于 A*，但它在计算路径时不受网格限制，可以在节点之间创建直线路径，从而找到更短的实际路径。
     *
     * 除了 A* 及其变种，还有其他一些算法也常用于路径规划，例如：
     * Dijkstra's Algorithm: 在没有启发式信息（即纯粹的最短路径搜索）的情况下使用。
     * Rapidly-exploring Random Tree (RRT): 主要用于连续空间和无人驾驶车辆等复杂环境中的路径规划。
     * Graph Search Algorithms: 如 Depth-First Search (DFS) 和 Breadth-First Search (BFS)，在某些简单或特定类型的路径寻找问题中仍然很有用。
     *
     * 随着技术的发展，新的算法和方法不断涌现，以应对更具挑战性的路径规划问题。
     * 例如，在机器人和自动驾驶车辆领域，考虑动力学约束、不确定性以及多智能体协作的路径规划算法越来越受到重视。
     * 总的来说，A* 和其变种算法因其灵活性和强大的性能仍然是业界常用的工具之一，但也会根据实际应用场景的不同需求选择最合适的路径规划算法。
     *
     *
     */

    /*
     * Rapidly-exploring Random Tree (RRT) 算法简介
     * Rapidly-exploring Random Tree（RRT）是一种用于解决路径规划问题的算法，尤其适合处理高维空间和复杂约束的情景。
     * 该算法由Steven M. LaValle在1998年提出，并迅速成为了机器人运动规划领域的一个重要工具。
     *
     * RRT基本原理：
     * 随机采样：RRT通过在搜索空间中随机采样点来逐步构建一个树形结构。
     * 树的增长：每次采样后，都会选择树中离采样点最近的节点作为父节点，并在这个方向上进行延伸，创建一个新的节点。
     * 连续探索：通过不断重复这个过程，RRT能够快速探索整个搜索空间。
     * 碰撞检测：构建过程中需要进行碰撞检测，确保生成的路径避开障碍物。
     *
     * RRT的特点：
     * 快速性：由于采样的随机性，RRT可以迅速探索出大范围的可行路径。
     * 适应性：能够很好地处理复杂的环境和非凸障碍物。
     * 非最优性：标准的RRT算法生成的路径通常不是最短的，但是变种如RRT*可以对路径进行优化，寻求更优解。
     * RRT在无人驾驶车辆中的应用
     * 在无人驾驶车辆的路径规划中，RRT可以用来高效地搜索从起点到目标点的可行路径，并且能够处理动态变化的环境和各种约束条件。
     *
     * 应用步骤：
     * 定义搜索空间：这包括车辆周围的环境，以及可能存在的动静态障碍物。
     * 初始化RRT：从无人车当前位置作为根节点开始构建RRT。
     * 随机采样：在搜索空间内随机采样新的点。
     * 找到最近节点：在树中找到距离新采样点最近的节点。
     * 路径延展：在最近节点和采样点之间按照某个步长延展新节点，并进行碰撞检测。
     * 插入新节点：如果新节点没有与障碍物发生碰撞，则将其作为子节点加入到树中。
     * 重复执行：重复步骤3至6，直到找到满足目标条件的路径或达到预设的迭代次数。
     * 路径提取：从树中提取从起始点到目标点的路径。
     * 路径优化（可选）：使用RRT*或其他算法对找到的路径进行优化，以使路径更加平滑、安全或更短等。
     *
     * 处理复杂环境：
     * 动态环境：在动态环境中，RRT可以实时更新树，以响应环境的变化。
     * 多目标规划：RRT可以被扩展为同时寻找多个目标的路径，例如，在停车场中规划一系列的停车位。
     * 车辆动力学约束：通过考虑车辆的转向角度限制、加速度等动力学特性，RRT能够生成实际可行的路径。
     *
     * 总结：
     * RRT及其变体因其简单、灵活且有效，常被用于无人驾驶车辆的路径规划。然而，RRT算法在实际应用中还需要针对具体场景和车辆特性进行调整和优化，以满足实时性、安全性和高效性的要求。
     */
}
