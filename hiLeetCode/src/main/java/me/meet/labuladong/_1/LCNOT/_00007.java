package me.meet.labuladong._1.LCNOT;

public final class _00007 {
    private _00007() {
    }
    /**
     * KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。
     * 很多读者抱怨 KMP 算法无法理解，这很正常，想到大学教材上关于 KMP 算法的讲解，也不知道有多少未来的 Knuth、Morris、Pratt 被提前劝退了。
     * 有一些优秀的同学通过手推 KMP 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。
     * 先在开头约定，本文用pat表示模式串，长度为M，txt表示文本串，长度为N。KMP 算法是在txt中查找子串pat，如果存在，返回这个子串的起始索引，否则返回 -1。
     * 为什么我认为 KMP 算法就是个动态规划问题呢，等会有解释。对于动态规划，之前多次强调了要明确dp数组的含义，而且同一个问题可能有不止一种定义dp数组含义的方法，不同的定义会有不同的解法。
     * 读者见过的 KMP 算法应该是，一波诡异的操作处理pat后形成一个一维的数组next，然后根据这个数组经过又一波复杂操作去匹配txt。时间复杂度 O(N)，空间复杂度 O(M)。
     * 其实它这个next数组就相当于dp数组，其中元素的含义跟pat的前缀和后缀有关，判定规则比较复杂，不太好理解。
     *
     * 本文则用一个二维的dp数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高。
     * PS：本文的代码参考《算法4》，原代码使用的数组名称是dfa（确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，本文还是沿用dp数组的名称。
     *
     *
     * 一、KMP 算法概述
     * 首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。
     * 暴力的字符串匹配算法很容易写，看一下它的运行逻辑：
     * // 暴力匹配（伪码）
     * int search(String pat, String txt) {
     *     int M = pat.length;
     *     int N = txt.length;
     *     for (int i = 0; i <= N - M; i++) {
     *         int j;
     *         for (j = 0; j < M; j++) {
     *             if (pat[j] != txt[i+j])
     *                 break;
     *         }
     *         // pat 全都匹配了
     *         if (j == M) return i;
     *     }
     *     // txt 中不存在 pat 子串
     *     return -1;
     * }
     *
     * 对于暴力算法，如果出现不匹配字符，同时回退txt和pat的指针，嵌套 for 循环，时间复杂度 O(MN)，空间复杂度O(1)。
     * 最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。
     *
     * 比如
     * txt = "aaacaaab"
     * pat = "aaab"：
     *
     * 很明显，pat中根本没有字符 c，根本没必要回退指针i，暴力解法明显多做了很多不必要的操作。
     * KMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：
     * 再比如类似的 txt = "aaaaaaab" pat = "aaab"，
     * 暴力解法还会和上面那个例子一样蠢蠢地回退指针i，而 KMP 算法又会耍聪明：
     * 因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。
     *
     * KMP 算法永不回退txt的指针i，不走回头路（不会重复扫描txt），而是借助dp数组中储存的信息把pat移到正确的位置继续匹配，时间复杂度只需 O(N)，用空间换时间，
     * 所以我认为它是一种动态规划算法。
     *
     *
     */

}
